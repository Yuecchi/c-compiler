/*******************************************************************************
*
* Parser generated by RDP on Jan 26 2021 16:28:31 from func.bnf
*
*******************************************************************************/
#include <time.h>
#include "arg.h"
#include "graph.h"
#include "memalloc.h"
#include "scan.h"
#include "set.h"
#include "symbol.h"
#include "textio.h"
#include "stdlib.h"
#include "ma_aux.h"
#include "tbl_aux.h"
#include "scope_chain.h"
#include "type.h"
#include "stack.h"
#include "rdparser.h"

char
 *rdp_sourcefilename = NULL,   /* source file name */
 *rdp_outputfilename = "func.out";         /* output file name */

int
  rdp_symbol_echo = 0,                 /* symbol echo flag */
  rdp_verbose = 0,                     /* verbosity flag */
  rdp_pass;                            /* pass number */

int rdp_error_return = 0;              /* return value for main routine */

char *rdp_tokens = "IGNORE\0" 
"ID\0" "INTEGER\0" "REAL\0" "CHAR\0" "CHAR_ESC\0" "STRING\0" "STRING_ESC\0" "COMMENT\0" 
"COMMENT_VISIBLE\0" "COMMENT_NEST\0" "COMMENT_NEST_VISIBLE\0" "COMMENT_LINE\0" "COMMENT_LINE_VISIBLE\0" "EOF\0" "EOLN\0" "'!'\0" 
"'!='\0" "'%'\0" "'('\0" "')'\0" "'*'\0" "'+'\0" "','\0" "'-'\0" 
"'/'\0" "';'\0" "'<'\0" "'<='\0" "'='\0" "'=='\0" "'>'\0" "'>='\0" 
"'break'\0" "'continue'\0" "'elif'\0" "'else'\0" "'if'\0" "'int'\0" "'print'\0" "'return'\0" 
"'while'\0" "'{'\0" "'}'\0" ;

table_data * table_temp = NULL;
void* table = NULL;

/* Load keywords */
static void rdp_load_keywords(void)
{
  scan_load_keyword("!", NULL, RDP_T_16 /* ! */, SCAN_P_IGNORE);
  scan_load_keyword("!=", NULL, RDP_T_17 /* != */, SCAN_P_IGNORE);
  scan_load_keyword("%", NULL, RDP_T_18 /* % */, SCAN_P_IGNORE);
  scan_load_keyword("(", NULL, RDP_T_19 /* ( */, SCAN_P_IGNORE);
  scan_load_keyword(")", NULL, RDP_T_20 /* ) */, SCAN_P_IGNORE);
  scan_load_keyword("*", NULL, RDP_T_21 /* * */, SCAN_P_IGNORE);
  scan_load_keyword("+", NULL, RDP_T_22 /* + */, SCAN_P_IGNORE);
  scan_load_keyword(",", NULL, RDP_T_23 /* , */, SCAN_P_IGNORE);
  scan_load_keyword("-", NULL, RDP_T_24 /* - */, SCAN_P_IGNORE);
  scan_load_keyword("/", NULL, RDP_T_25 /* / */, SCAN_P_IGNORE);
  scan_load_keyword(";", NULL, RDP_T_26 /* ; */, SCAN_P_IGNORE);
  scan_load_keyword("<", NULL, RDP_T_27 /* < */, SCAN_P_IGNORE);
  scan_load_keyword("<=", NULL, RDP_T_28 /* <= */, SCAN_P_IGNORE);
  scan_load_keyword("=", NULL, RDP_T_29 /* = */, SCAN_P_IGNORE);
  scan_load_keyword("==", NULL, RDP_T_30 /* == */, SCAN_P_IGNORE);
  scan_load_keyword(">", NULL, RDP_T_31 /* > */, SCAN_P_IGNORE);
  scan_load_keyword(">=", NULL, RDP_T_32 /* >= */, SCAN_P_IGNORE);
  scan_load_keyword("break", NULL, RDP_T_break, SCAN_P_IGNORE);
  scan_load_keyword("continue", NULL, RDP_T_continue, SCAN_P_IGNORE);
  scan_load_keyword("elif", NULL, RDP_T_elif, SCAN_P_IGNORE);
  scan_load_keyword("else", NULL, RDP_T_else, SCAN_P_IGNORE);
  scan_load_keyword("if", NULL, RDP_T_if, SCAN_P_IGNORE);
  scan_load_keyword("int", NULL, RDP_T_int, SCAN_P_IGNORE);
  scan_load_keyword("print", NULL, RDP_T_print, SCAN_P_IGNORE);
  scan_load_keyword("return", NULL, RDP_T_return, SCAN_P_IGNORE);
  scan_load_keyword("while", NULL, RDP_T_while, SCAN_P_IGNORE);
  scan_load_keyword("{", NULL, RDP_T_42 /* { */, SCAN_P_IGNORE);
  scan_load_keyword("}", NULL, RDP_T_43 /* } */, SCAN_P_IGNORE);
}

/* Set declarations */

  set_ ARGS_first = SET_NULL;
  set_ ARGS_stop = SET_NULL;
  set_ ASSIGN_stop = SET_NULL;
  set_ BOOL_first = SET_NULL;
  set_ BOOL_stop = SET_NULL;
  set_ BREAK_stop = SET_NULL;
  set_ COND_stop = SET_NULL;
  set_ CONTINUE_stop = SET_NULL;
  set_ DECL_stop = SET_NULL;
  set_ EXPR_first = SET_NULL;
  set_ EXPR_stop = SET_NULL;
  set_ FUNC_CALL_stop = SET_NULL;
  set_ FUNC_DECL_stop = SET_NULL;
  set_ PARAMS_stop = SET_NULL;
  set_ PRIMITIVE_first = SET_NULL;
  set_ PRIMITIVE_stop = SET_NULL;
  set_ PRINT_stop = SET_NULL;
  set_ PROD_first = SET_NULL;
  set_ PROD_stop = SET_NULL;
  set_ RETURN_stop = SET_NULL;
  set_ SCOPE_stop = SET_NULL;
  set_ SUM_first = SET_NULL;
  set_ SUM_stop = SET_NULL;
  set_ TRNS_UNIT_stop = SET_NULL;
  set_ UNARY_first = SET_NULL;
  set_ UNARY_stop = SET_NULL;
  set_ VAR_DECL_first = SET_NULL;
  set_ VAR_DECL_stop = SET_NULL;
  set_ WHILE_stop = SET_NULL;
  set_ rdp_ARGS_2_first = SET_NULL;
  set_ rdp_BOOL_6_first = SET_NULL;
  set_ rdp_BOOL_7_first = SET_NULL;
  set_ rdp_EXPR_0_first = SET_NULL;
  set_ rdp_FUNC_CALL_0_first = SET_NULL;
  set_ rdp_FUNC_CALL_1_first = SET_NULL;
  set_ rdp_PROD_3_first = SET_NULL;
  set_ rdp_PROD_4_first = SET_NULL;
  set_ rdp_RETURN_0_first = SET_NULL;
  set_ rdp_RETURN_1_first = SET_NULL;
  set_ rdp_SCOPE_10_first = SET_NULL;
  set_ rdp_SCOPE_14_first = SET_NULL;
  set_ rdp_SCOPE_3_first = SET_NULL;
  set_ rdp_SCOPE_9_first = SET_NULL;
  set_ rdp_SUM_2_first = SET_NULL;
  set_ rdp_SUM_3_first = SET_NULL;
  set_ rdp_TRNS_UNIT_0_first = SET_NULL;
  set_ rdp_TRNS_UNIT_2_first = SET_NULL;
  set_ rdp_UNARY_0_first = SET_NULL;
  set_ rdp_VAR_DECL_2_first = SET_NULL;

/* Initialise sets */

static void rdp_set_initialise(void)
{
  set_assign_list(&ARGS_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&ARGS_stop, SCAN_P_EOF, RDP_T_20 /* ) */,SET_END);
  set_assign_list(&ASSIGN_stop, SCAN_P_EOF, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&BOOL_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&BOOL_stop, SCAN_P_EOF, RDP_T_20 /* ) */, RDP_T_23 /* , */, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&BREAK_stop, SCAN_P_EOF, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&COND_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_break, RDP_T_continue, RDP_T_if, RDP_T_int, RDP_T_print, 
RDP_T_return, RDP_T_while, RDP_T_42 /* { */, RDP_T_43 /* } */,SET_END);
  set_assign_list(&CONTINUE_stop, SCAN_P_EOF, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&DECL_stop, SCAN_P_EOF, RDP_T_19 /* ( */, RDP_T_20 /* ) */, RDP_T_23 /* , */, RDP_T_26 /* ; */, 
RDP_T_29 /* = */,SET_END);
  set_assign_list(&EXPR_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&EXPR_stop, SCAN_P_EOF, RDP_T_20 /* ) */, RDP_T_23 /* , */, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&FUNC_CALL_stop, SCAN_P_EOF, RDP_T_17 /* != */, RDP_T_18 /* % */, RDP_T_20 /* ) */, RDP_T_21 /* * */, 
RDP_T_22 /* + */, RDP_T_23 /* , */, RDP_T_24 /* - */, RDP_T_25 /* / */, RDP_T_26 /* ; */, 
RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, RDP_T_31 /* > */, RDP_T_32 /* >= */,SET_END);
  set_assign_list(&FUNC_DECL_stop, SCAN_P_EOF, RDP_T_int,SET_END);
  set_assign_list(&PARAMS_stop, SCAN_P_EOF, RDP_T_20 /* ) */,SET_END);
  set_assign_list(&PRIMITIVE_first, SCAN_P_ID, SCAN_P_INTEGER, SET_END);
  set_assign_list(&PRIMITIVE_stop, SCAN_P_EOF, RDP_T_17 /* != */, RDP_T_18 /* % */, RDP_T_20 /* ) */, RDP_T_21 /* * */, 
RDP_T_22 /* + */, RDP_T_23 /* , */, RDP_T_24 /* - */, RDP_T_25 /* / */, RDP_T_26 /* ; */, 
RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, RDP_T_31 /* > */, RDP_T_32 /* >= */,SET_END);
  set_assign_list(&PRINT_stop, SCAN_P_EOF, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&PROD_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&PROD_stop, SCAN_P_EOF, RDP_T_17 /* != */, RDP_T_20 /* ) */, RDP_T_22 /* + */, RDP_T_23 /* , */, 
RDP_T_24 /* - */, RDP_T_26 /* ; */, RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, 
RDP_T_31 /* > */, RDP_T_32 /* >= */,SET_END);
  set_assign_list(&RETURN_stop, SCAN_P_EOF, RDP_T_26 /* ; */,SET_END);
  set_assign_list(&SCOPE_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_break, RDP_T_continue, RDP_T_elif, RDP_T_else, RDP_T_if, 
RDP_T_int, RDP_T_print, RDP_T_return, RDP_T_while, RDP_T_42 /* { */, RDP_T_43 /* } */,SET_END);
  set_assign_list(&SUM_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&SUM_stop, SCAN_P_EOF, RDP_T_17 /* != */, RDP_T_20 /* ) */, RDP_T_23 /* , */, RDP_T_26 /* ; */, 
RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, RDP_T_31 /* > */, RDP_T_32 /* >= */,SET_END);
  set_assign_list(&TRNS_UNIT_stop, SCAN_P_EOF,SET_END);
  set_assign_list(&UNARY_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&UNARY_stop, SCAN_P_EOF, RDP_T_17 /* != */, RDP_T_18 /* % */, RDP_T_20 /* ) */, RDP_T_21 /* * */, 
RDP_T_22 /* + */, RDP_T_23 /* , */, RDP_T_24 /* - */, RDP_T_25 /* / */, RDP_T_26 /* ; */, 
RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, RDP_T_31 /* > */, RDP_T_32 /* >= */,SET_END);
  set_assign_list(&VAR_DECL_first, RDP_T_26 /* ; */, RDP_T_29 /* = */, SET_END);
  set_assign_list(&VAR_DECL_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_break, RDP_T_continue, RDP_T_if, RDP_T_int, RDP_T_print, 
RDP_T_return, RDP_T_while, RDP_T_42 /* { */, RDP_T_43 /* } */,SET_END);
  set_assign_list(&WHILE_stop, SCAN_P_ID, SCAN_P_EOF, RDP_T_break, RDP_T_continue, RDP_T_if, RDP_T_int, RDP_T_print, 
RDP_T_return, RDP_T_while, RDP_T_42 /* { */, RDP_T_43 /* } */,SET_END);
  set_assign_list(&rdp_ARGS_2_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_BOOL_6_first, RDP_T_17 /* != */, RDP_T_27 /* < */, RDP_T_28 /* <= */, RDP_T_30 /* == */, RDP_T_31 /* > */, 
RDP_T_32 /* >= */, SET_END);
  set_assign_list(&rdp_BOOL_7_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_EXPR_0_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_FUNC_CALL_0_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_FUNC_CALL_1_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_PROD_3_first, RDP_T_18 /* % */, RDP_T_21 /* * */, RDP_T_25 /* / */, SET_END);
  set_assign_list(&rdp_PROD_4_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_RETURN_0_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_RETURN_1_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_SCOPE_10_first, SCAN_P_ID, RDP_T_break, RDP_T_continue, RDP_T_print, RDP_T_return, SET_END);
  set_assign_list(&rdp_SCOPE_14_first, SCAN_P_ID, RDP_T_break, RDP_T_continue, RDP_T_if, RDP_T_int, RDP_T_print, RDP_T_return, 
RDP_T_while, RDP_T_42 /* { */, SET_END);
  set_assign_list(&rdp_SCOPE_3_first, RDP_T_19 /* ( */, RDP_T_29 /* = */, SET_END);
  set_assign_list(&rdp_SCOPE_9_first, SCAN_P_ID, RDP_T_break, RDP_T_continue, RDP_T_print, RDP_T_return, SET_END);
  set_assign_list(&rdp_SUM_2_first, RDP_T_22 /* + */, RDP_T_24 /* - */, SET_END);
  set_assign_list(&rdp_SUM_3_first, SCAN_P_ID, SCAN_P_INTEGER, RDP_T_19 /* ( */, SET_END);
  set_assign_list(&rdp_TRNS_UNIT_0_first, RDP_T_26 /* ; */, RDP_T_29 /* = */, SET_END);
  set_assign_list(&rdp_TRNS_UNIT_2_first, RDP_T_19 /* ( */, RDP_T_26 /* ; */, RDP_T_29 /* = */, SET_END);
  set_assign_list(&rdp_UNARY_0_first, SCAN_P_ID, SCAN_P_INTEGER, SET_END);
  set_assign_list(&rdp_VAR_DECL_2_first, RDP_T_26 /* ; */, RDP_T_29 /* = */, SET_END);
}

/* Parser forward declarations and macros */
static int ARGS(void);
static void ASSIGN(char* name);
static char* BOOL(void);
static void BREAK(void);
static int COND(int offset);
static void CONTINUE(void);
static char* DECL(void);
static char* EXPR(void);
static char* FUNC_CALL(char* name, int assign);
static void FUNC_DECL(char* name);
static int PARAMS(void* scp);
static char* PRIMITIVE(void);
static void PRINT(void);
static char* PROD(void);
static void RETURN(void);
static int SCOPE(void* scp, int offset);
static char* SUM(void);
void TRNS_UNIT(void);
static char* UNARY(void);
static void VAR_DECL(char* name, int offset);
static int WHILE(int offset);

/* Parser functions */
static int ARGS(void)
{
  int result;
  char* val;
  {
    val = EXPR();
     result = 1; \
                         fprintf(fp, "\tpush %s %d\n", val, result * 4); \
                  
    if (scan_test(NULL, RDP_T_23 /* , */, NULL))
    { /* Start of rdp_ARGS_1 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_23 /* , */, &ARGS_stop);
          scan_();
          val = EXPR();
           result += 1;  \
                           fprintf(fp, "\tpush %s %d\n", val, result * 4); \
                        
          }
        if (!scan_test(NULL, RDP_T_23 /* , */, NULL)) break;
      }
    } /* end of rdp_ARGS_1 */
    scan_test_set(NULL, &ARGS_stop, &ARGS_stop);
   }
  return result;
}

static void ASSIGN(char* name)
{
  char* val;
  {
    if (scan_test(NULL, RDP_T_29 /* = */, NULL))
    { /* Start of rdp_ASSIGN_1 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_29 /* = */, &ASSIGN_stop);
          scan_();
          val = EXPR();
           void **chain = this_scope(); \
         void *key; \
         while (chain) { \
                 if ((key = symbol_lookup_key(table, &name, *chain))) { \
                         if (table_cast(key)->type != INT) { \
                                 text_message(TEXT_ERROR, "'%s' is not an integer\n", name); \
                         } \
                         break; \
                 } \
                 chain = prev_scope(chain); \
         } \
         if (!key) { \
                 text_message(TEXT_ERROR, "'%s' undeclared\n", name); \
         } else { \
                 int offset = table_cast(key)->offset; \
                 if (offset) { \
                         fprintf(fp, "\t$fp(%d) = %s\n", offset, val); \
                 } else { \
                         fprintf(fp, "\t%s = %s\n", name, val); \
                 } \
         } \
        
          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_ASSIGN_1 */
    scan_test_set(NULL, &ASSIGN_stop, &ASSIGN_stop);
   }
}

static char* BOOL(void)
{
  char* result;
  char* val1;
  char* val2;
  {
    val1 = SUM();
     result = val1; 
    if (scan_test_set(NULL, &rdp_BOOL_6_first, NULL))
    { /* Start of rdp_BOOL_6 */
      while (1)
      {
        {
          if (scan_test(NULL, RDP_T_30 /* == */, NULL))
          {
            scan_test(NULL, RDP_T_30 /* == */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                fprintf(fp, "\t%s = %s == %s\n", result, val1, val2); \
                                val1 = result; \
                             
          }
          else
          if (scan_test(NULL, RDP_T_32 /* >= */, NULL))
          {
            scan_test(NULL, RDP_T_32 /* >= */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                fprintf(fp, "\t%s = %s >= %s\n", result, val1, val2); \
                                val1 = result; \
                             
          }
          else
          if (scan_test(NULL, RDP_T_31 /* > */, NULL))
          {
            scan_test(NULL, RDP_T_31 /* > */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                        fprintf(fp, "\t%s = %s > %s\n", result, val1, val2); \
                                        val1 = result; \
                                 
          }
          else
          if (scan_test(NULL, RDP_T_28 /* <= */, NULL))
          {
            scan_test(NULL, RDP_T_28 /* <= */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                        fprintf(fp, "\t%s = %s <= %s\n", result, val1, val2); \
                                        val1 = result; \
                                 
          }
          else
          if (scan_test(NULL, RDP_T_27 /* < */, NULL))
          {
            scan_test(NULL, RDP_T_27 /* < */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                        fprintf(fp, "\t%s = %s < %s\n", result, val1, val2); \
                                        val1 = result; \
                                 
          }
          else
          if (scan_test(NULL, RDP_T_17 /* != */, NULL))
          {
            scan_test(NULL, RDP_T_17 /* != */, &BOOL_stop);
            scan_();
            val2 = SUM();
             result = new_temp(); \
                                        fprintf(fp, "\t%s = %s != %s\n", result, val1, val2); \
                                        val1 = result; \
                                 
          }
          else
            scan_test_set(NULL, &rdp_BOOL_6_first, &BOOL_stop)          ;
          }
        if (!scan_test_set(NULL, &rdp_BOOL_6_first, NULL)) break;
      }
    } /* end of rdp_BOOL_6 */
    scan_test_set(NULL, &BOOL_stop, &BOOL_stop);
   }
  return result;
}

static void BREAK(void)
{
  {
    scan_test(NULL, RDP_T_break, &BREAK_stop);
    scan_();
     char** label = ((char**)peek(&loop_stack)); \
                                         if (!label) { \
                                                text_message(TEXT_ERROR, "use of 'break' must be within a loop\n"); \
                                         } else { \
                                            int end = 1 + atoi((*label) + 2); \
                                                fprintf(fp, "\tgoto L%i\n", end); \
                                         } \
                                  
    scan_test_set(NULL, &BREAK_stop, &BREAK_stop);
   }
}

static int COND(int offset)
{
  int result;
  char* val;
  int declarations;
  {
     result = 0; 
    scan_test(NULL, RDP_T_if, &COND_stop);
    scan_();
    scan_test(NULL, RDP_T_19 /* ( */, &COND_stop);
    scan_();
    val = EXPR();
    scan_test(NULL, RDP_T_20 /* ) */, &COND_stop);
    scan_();
     char* end = new_lab(); \
    char* lab = new_lab(); \
    void *scp = symbol_new_scope(table, NULL); \
    link_scope(scp); \
    fprintf(fp, "\tif %s == 0 goto %s\n", val, lab + 1); \
 
    declarations = SCOPE(scp, offset);
     \
        result += declarations; \
        fprintf(fp, "\tgoto %s\n", end + 1); \
    fprintf(fp, "%s\n", lab); \
 
    if (scan_test(NULL, RDP_T_elif, NULL))
    { /* Start of rdp_COND_1 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_elif, &COND_stop);
          scan_();
          scan_test(NULL, RDP_T_19 /* ( */, &COND_stop);
          scan_();
          val = EXPR();
          scan_test(NULL, RDP_T_20 /* ) */, &COND_stop);
          scan_();
           lab = new_lab(); \
          scp = symbol_new_scope(table, NULL); \
          link_scope(scp); \
      fprintf(fp, "\tif %s == 0 goto %s\n", val, lab + 1); \
   
          declarations = SCOPE(scp, offset);
           result += declarations; \
          fprintf(fp, "\tgoto %s\n", end + 1); \
      fprintf(fp, "%s\n", lab); \
   
          }
        if (!scan_test(NULL, RDP_T_elif, NULL)) break;
      }
    } /* end of rdp_COND_1 */
     scp = symbol_new_scope(table, NULL); \
        link_scope(scp); \
 
    if (scan_test(NULL, RDP_T_else, NULL))
    { /* Start of rdp_COND_3 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_else, &COND_stop);
          scan_();
          declarations = SCOPE(scp, offset);
          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_COND_3 */
     result += declarations; \
    fprintf(fp, "%s\n", end);  \
 
    scan_test_set(NULL, &COND_stop, &COND_stop);
   }
  return result;
}

static void CONTINUE(void)
{
  {
    scan_test(NULL, RDP_T_continue, &CONTINUE_stop);
    scan_();
     char** label = ((char**)peek(&loop_stack)); \
                                                   if (!label) { \
                                                       text_message(TEXT_ERROR, "use of 'continue' must be within a loop\n"); \
                                               } else { \
                                                       fprintf(fp, "\tgoto %s\n", (*label) + 1); \
                                               } \
                                        
    scan_test_set(NULL, &CONTINUE_stop, &CONTINUE_stop);
   }
}

static char* DECL(void)
{
  char* result;
  {
    scan_test(NULL, RDP_T_int, &DECL_stop);
    scan_();
    scan_test(NULL, SCAN_P_ID, &DECL_stop);
    result = SCAN_CAST->id;
    scan_();
    scan_test_set(NULL, &DECL_stop, &DECL_stop);
   }
  return result;
}

static char* EXPR(void)
{
  char* result;
  {
    result = BOOL();
    scan_test_set(NULL, &EXPR_stop, &EXPR_stop);
   }
  return result;
}

static char* FUNC_CALL(char* name, int assign)
{
  char* result;
  int args;
  {
      void **chain = this_scope(); \
        if (*chain == global_scope) { \
                text_message(TEXT_ERROR, "initializer element '%s' is not constant\n", name); \
        } \
        void *key; \
        args = 0; \
        while (chain) { \
                if ((key = symbol_lookup_key(table, &name, *chain))) { \
                        if (table_cast(key)->type != FUNC) { \
                            text_message(TEXT_ERROR, "'%s' is not a function or function pointer\n", name); \
                        } \
                    break; \
                } \
                chain = prev_scope(chain); \
        } \
        if (!key) { \
                text_message(TEXT_ERROR, "'%s' undeclared\n", name); \
        } else { \
                result = mem_malloc(7 + strlen(name)); \
                sprintf(result, "call %s", name); \
                fprintf(fp, "\tpush $fp\n"); \
                fprintf(fp, "\tpush 4\n");  \
        } \
 
    scan_test(NULL, RDP_T_19 /* ( */, &FUNC_CALL_stop);
    scan_();
    if (scan_test_set(NULL, &rdp_FUNC_CALL_1_first, NULL))
    { /* Start of rdp_FUNC_CALL_1 */
      while (1)
      {
        {
          args = ARGS();
          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_FUNC_CALL_1 */
     if (key) { \
                        if (table_cast(key)->params != args) { \
                                text_message(TEXT_ERROR, "parameter mismatch in function '%s'\n", name); \
                        } \
                } \
         
    scan_test(NULL, RDP_T_20 /* ) */, &FUNC_CALL_stop);
    scan_();
     if (!assign) fprintf(fp, "\tcall %s\n", name); 
    scan_test_set(NULL, &FUNC_CALL_stop, &FUNC_CALL_stop);
   }
  return result;
}

static void FUNC_DECL(char* name)
{
  int params;
  int declarations;
  {
     void *key = 0; \
   int size = 4; \
   int locals = 0; \
   if (symbol_lookup_key(table, &name, *this_scope())) { \
       text_message(TEXT_ERROR, "redeclaration of '%s'\n", name); \
   } else { \
       key = symbol_insert_key(table, &name, sizeof(char*), sizeof(table_data)); \
       table_cast(key)->type = FUNC; \
       fprintf(fp, "#%s\n", name); \
       if (strcmp(name, "main")) { \
               fprintf(fp, "\tpush $ra\n"); \
           } else { \
               fprintf(fp, "\tpush $sp\n"); \
           } \
   } \

    scan_test(NULL, RDP_T_19 /* ( */, &FUNC_DECL_stop);
    scan_();
     void *scp = symbol_new_scope(table, NULL); \
           link_scope(scp); \
           if (!strcmp(name, "main")) { \
               main_scope = scp; \
           } \
        
    if (scan_test(NULL, RDP_T_int, NULL))
    { /* Start of rdp_FUNC_DECL_1 */
      while (1)
      {
        {
          params = PARAMS(scp);
           if (key) { \
             table_cast(key)->params = params; \
             size += (4 * params); \
             if (!strcmp(name, "main")) { \
                fprintf(fp, "\tpush %i\n", 4 * params); \
             }  \
         }  \
  
          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_FUNC_DECL_1 */
    scan_test(NULL, RDP_T_20 /* ) */, &FUNC_DECL_stop);
    scan_();
    declarations = SCOPE(scp, size);
          locals = declarations; \
        size += (4 * declarations) + 4; \
        table_cast(key)->size = size; \
        if (scp != main_scope) { \
                fprintf(fp, "\treturn\n"); \
    } else { \
        fprintf(fp, "\tterminate\n"); \
    } \
    fprintf(ft, "%s %d %d\n", name, FUNC, locals);  \

    scan_test_set(NULL, &FUNC_DECL_stop, &FUNC_DECL_stop);
   }
}

static int PARAMS(void* scp)
{
  int result;
  char* name;
  {
    name = DECL();
     void* key = symbol_insert_key(table, &name, sizeof(char*), sizeof(table_data)); \
         int offset; \
         result = 1; \
         table_cast(key)->type = INT; \
         offset = table_cast(key)->offset = result * 4; \
  
    if (scan_test(NULL, RDP_T_23 /* , */, NULL))
    { /* Start of rdp_PARAMS_1 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_23 /* , */, &PARAMS_stop);
          scan_();
          name = DECL();
           if (symbol_lookup_key(table, &name, scp)) { \
               text_message(TEXT_ERROR, "redeclaration of '%s'\n", name); \
           } else { \
                   key = symbol_insert_key(table, &name, sizeof(char*), sizeof(table_data)); \
                   result += 1; \
                   table_cast(key)->type = INT; \
                   offset  = table_cast(key)->offset = result * 4; \
           } \
    
          }
        if (!scan_test(NULL, RDP_T_23 /* , */, NULL)) break;
      }
    } /* end of rdp_PARAMS_1 */
    scan_test_set(NULL, &PARAMS_stop, &PARAMS_stop);
   }
  return result;
}

static char* PRIMITIVE(void)
{
  char* result;
  long int val;
  char* name;
  char* call;
  {
    if (scan_test(NULL, SCAN_P_INTEGER, NULL))
    {
      scan_test(NULL, SCAN_P_INTEGER, &PRIMITIVE_stop);
      val = SCAN_CAST->data.i;
      scan_();
       result = (char*) mem_malloc(12); \
                                                 sprintf(result, "%li", val); \
                                          
    }
    else
    if (scan_test(NULL, SCAN_P_ID, NULL))
    {
       int func = 0; 
      scan_test(NULL, SCAN_P_ID, &PRIMITIVE_stop);
      name = SCAN_CAST->id;
      scan_();
      if (scan_test(NULL, RDP_T_19 /* ( */, NULL))
      { /* Start of rdp_PRIMITIVE_2 */
        while (1)
        {
          {
            call = FUNC_CALL(name, 1);
             func = 1; \
                                                                   result = call; \
                                                                
            }
          break;   /* hi limit is 1! */
        }
      } /* end of rdp_PRIMITIVE_2 */
       if (!func) { \
                                                         void **chain = this_scope(); \
                                                         void *key; \
                                                         while (chain) { \
                                                             if ((key = symbol_lookup_key(table, &name, *chain))) { \
                                                                     if (table_cast(key)->type != INT) { \
                                                                             text_message(TEXT_ERROR, "'%s' is not an integer\n", name); \
                                                                         } \
                                                                     break; \
                                                                 } \
                                                                 chain = prev_scope(chain); \
                                                         } \
                                                         if (!key) { \
                                                                 text_message(TEXT_ERROR, "'%s' undeclared\n", name); \
                                                         } else { \
                                                                 int offset = table_cast(key)->offset; \
                                                                 if (offset) { \
                                                                        result = (char*) mem_malloc(15); \
                                                                        sprintf(result, "$fp(%d)", offset); \
                                                                 } else { \
                                                                        result = name; \
                                                                 } \
                                                         } \
                                                 } \
                                          
    }
    else
      scan_test_set(NULL, &PRIMITIVE_first, &PRIMITIVE_stop)    ;
    scan_test_set(NULL, &PRIMITIVE_stop, &PRIMITIVE_stop);
   }
  return result;
}

static void PRINT(void)
{
  char* val;
  {
    scan_test(NULL, RDP_T_print, &PRINT_stop);
    scan_();
    scan_test(NULL, RDP_T_19 /* ( */, &PRINT_stop);
    scan_();
    val = EXPR();
    scan_test(NULL, RDP_T_20 /* ) */, &PRINT_stop);
    scan_();
     fprintf(fp, "\tprint %s\n", val); \
                  
    scan_test_set(NULL, &PRINT_stop, &PRINT_stop);
   }
}

static char* PROD(void)
{
  char* result;
  char* val1;
  char* val2;
  {
    val1 = UNARY();
     result = val1; 
    if (scan_test_set(NULL, &rdp_PROD_3_first, NULL))
    { /* Start of rdp_PROD_3 */
      while (1)
      {
        {
          if (scan_test(NULL, RDP_T_21 /* * */, NULL))
          {
            scan_test(NULL, RDP_T_21 /* * */, &PROD_stop);
            scan_();
            val2 = UNARY();
             result = new_temp(); \
                                fprintf(fp, "\t%s = %s * %s\n", result, val1, val2); \
                                val1 = result; \
                             
          }
          else
          if (scan_test(NULL, RDP_T_25 /* / */, NULL))
          {
            scan_test(NULL, RDP_T_25 /* / */, &PROD_stop);
            scan_();
            val2 = UNARY();
             result = new_temp(); \
                                fprintf(fp, "\t%s = %s / %s\n", result, val1, val2); \
                                val1 = result; \
                             
          }
          else
          if (scan_test(NULL, RDP_T_18 /* % */, NULL))
          {
            scan_test(NULL, RDP_T_18 /* % */, &PROD_stop);
            scan_();
            val2 = UNARY();
             result = new_temp(); \
                                fprintf(fp, "\t%s = %s %% %s\n", result, val1, val2); \
                                val1 = result; \
                             
          }
          else
            scan_test_set(NULL, &rdp_PROD_3_first, &PROD_stop)          ;
          }
        if (!scan_test_set(NULL, &rdp_PROD_3_first, NULL)) break;
      }
    } /* end of rdp_PROD_3 */
    scan_test_set(NULL, &PROD_stop, &PROD_stop);
   }
  return result;
}

static void RETURN(void)
{
  char* val;
  {
    scan_test(NULL, RDP_T_return, &RETURN_stop);
    scan_();
    if (scan_test_set(NULL, &rdp_RETURN_1_first, NULL))
    { /* Start of rdp_RETURN_1 */
      while (1)
      {
        {
          val = EXPR();
           if (*this_scope() != main_scope) { \
                                                 fprintf(fp, "\treturn %s\n", val); \
                                             } else { \
                                                 fprintf(fp, "\tterminate\n"); \
                                             }  \
                                          
          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_RETURN_1 */
    scan_test_set(NULL, &RETURN_stop, &RETURN_stop);
   }
}

static int SCOPE(void* scp, int offset)
{
  int result;
  char* name;
  int declarations;
  {
     result = 0; 
    scan_test(NULL, RDP_T_42 /* { */, &SCOPE_stop);
    scan_();
    if (scan_test_set(NULL, &rdp_SCOPE_14_first, NULL))
    { /* Start of rdp_SCOPE_14 */
      while (1)
      {
        {
          if (scan_test(NULL, RDP_T_int, NULL))
          {
            name = DECL();
            VAR_DECL(name, offset);
             offset += 4;  \
         result += 1;  \
      
          }
          else
          if (scan_test_set(NULL, &rdp_SCOPE_10_first, NULL))
          {
            { /* Start of rdp_SCOPE_9 */
              while (1)
              {
                scan_test_set(NULL, &rdp_SCOPE_9_first, &SCOPE_stop);
                {
                  if (scan_test(NULL, SCAN_P_ID, NULL))
                  {
                    scan_test(NULL, SCAN_P_ID, &SCOPE_stop);
                    name = SCAN_CAST->id;
                    scan_();
                    { /* Start of rdp_SCOPE_3 */
                      while (1)
                      {
                        {
                          if (scan_test(NULL, RDP_T_19 /* ( */, NULL))
                          {
                            FUNC_CALL(name, 0);
                          }
                          else
                          if (scan_test(NULL, RDP_T_29 /* = */, NULL))
                          {
                            ASSIGN(name);
                          }
                          }
                        break;   /* hi limit is 1! */
                      }
                    } /* end of rdp_SCOPE_3 */
                  }
                  else
                  if (scan_test(NULL, RDP_T_return, NULL))
                  {
                    RETURN();
                  }
                  else
                  if (scan_test(NULL, RDP_T_print, NULL))
                  {
                    PRINT();
                  }
                  else
                  if (scan_test(NULL, RDP_T_break, NULL))
                  {
                    BREAK();
                  }
                  else
                  if (scan_test(NULL, RDP_T_continue, NULL))
                  {
                    CONTINUE();
                  }
                  else
                    scan_test_set(NULL, &rdp_SCOPE_9_first, &SCOPE_stop)                  ;
                  }
                break;   /* hi limit is 1! */
              }
            } /* end of rdp_SCOPE_9 */
            scan_test(NULL, RDP_T_26 /* ; */, &SCOPE_stop);
            scan_();
          }
          else
          if (scan_test(NULL, RDP_T_if, NULL))
          {
            declarations = COND(offset);
             result += declarations; 
          }
          else
          if (scan_test(NULL, RDP_T_while, NULL))
          {
            declarations = WHILE(offset);
             result += declarations; 
          }
          else
          if (scan_test(NULL, RDP_T_42 /* { */, NULL))
          {
             void *new_scope = symbol_new_scope(table, NULL);  \
         link_scope(new_scope);  \
      
            declarations = SCOPE(new_scope, offset);
             result += declarations; 
          }
          else
            scan_test_set(NULL, &rdp_SCOPE_14_first, &SCOPE_stop)          ;
          }
        if (!scan_test_set(NULL, &rdp_SCOPE_14_first, NULL)) break;
      }
    } /* end of rdp_SCOPE_14 */
    scan_test(NULL, RDP_T_43 /* } */, &SCOPE_stop);
    scan_();
     symbol_unlink_scope(table);  \
    unlink_scope(); \
    symbol_set_scope(table, *this_scope()); \
 
    scan_test_set(NULL, &SCOPE_stop, &SCOPE_stop);
   }
  return result;
}

static char* SUM(void)
{
  char* result;
  char* val1;
  char* val2;
  {
    val1 = PROD();
     result = val1; 
    if (scan_test_set(NULL, &rdp_SUM_2_first, NULL))
    { /* Start of rdp_SUM_2 */
      while (1)
      {
        {
          if (scan_test(NULL, RDP_T_22 /* + */, NULL))
          {
            scan_test(NULL, RDP_T_22 /* + */, &SUM_stop);
            scan_();
            val2 = PROD();
             result = new_temp(); \
                                         fprintf(fp, "\t%s = %s + %s\n", result, val1, val2); \
                                         val1 = result; \
                                  
          }
          else
          if (scan_test(NULL, RDP_T_24 /* - */, NULL))
          {
            scan_test(NULL, RDP_T_24 /* - */, &SUM_stop);
            scan_();
            val2 = PROD();
             result = new_temp(); \
                             fprintf(fp, "\t%s = %s - %s\n", result, val1, val2); \
                             val1 = result; \
                          
          }
          else
            scan_test_set(NULL, &rdp_SUM_2_first, &SUM_stop)          ;
          }
        if (!scan_test_set(NULL, &rdp_SUM_2_first, NULL)) break;
      }
    } /* end of rdp_SUM_2 */
    scan_test_set(NULL, &SUM_stop, &SUM_stop);
   }
  return result;
}

void TRNS_UNIT(void)
{
  char* name;
  {
     fp = fopen("func.tac", "w");  \
                                 ft = fopen("func.tbl", "w"); \
                                 link_scope(symbol_get_scope(table)); \
                                 global_scope = *this_scope(); \
                          
    if (scan_test(NULL, RDP_T_int, NULL))
    { /* Start of rdp_TRNS_UNIT_4 */
      while (1)
      {
        {
          name = DECL();
          { /* Start of rdp_TRNS_UNIT_2 */
            while (1)
            {
              scan_test_set(NULL, &rdp_TRNS_UNIT_2_first, &TRNS_UNIT_stop);
              {
                if (scan_test_set(NULL, &rdp_TRNS_UNIT_0_first, NULL))
                {
                  VAR_DECL(name, 0);
                }
                else
                if (scan_test(NULL, RDP_T_19 /* ( */, NULL))
                {
                  FUNC_DECL(name);
                }
                else
                  scan_test_set(NULL, &rdp_TRNS_UNIT_2_first, &TRNS_UNIT_stop)                ;
                }
              break;   /* hi limit is 1! */
            }
          } /* end of rdp_TRNS_UNIT_2 */
          }
        if (!scan_test(NULL, RDP_T_int, NULL)) break;
      }
    } /* end of rdp_TRNS_UNIT_4 */
     fclose(fp); \
                                 fclose(ft); \
                                 if (!main_scope) { \
                                        text_message(TEXT_ERROR, "no main function has been declared\n"); \
                                 } \
                          
    scan_test_set(NULL, &TRNS_UNIT_stop, &TRNS_UNIT_stop);
   }
}

static char* UNARY(void)
{
  char* result;
  char* val1;
  {
    if (scan_test_set(NULL, &rdp_UNARY_0_first, NULL))
    {
      val1 = PRIMITIVE();
       result = new_temp();  \
                                                                  fprintf(fp, "\t%s = %s\n", result, val1); \
                                                                  val1 = result; \
                                                           
    }
    else
    if (scan_test(NULL, RDP_T_19 /* ( */, NULL))
    {
      scan_test(NULL, RDP_T_19 /* ( */, &UNARY_stop);
      scan_();
      val1 = EXPR();
       result = val1; 
      scan_test(NULL, RDP_T_20 /* ) */, &UNARY_stop);
      scan_();
    }
    else
      scan_test_set(NULL, &UNARY_first, &UNARY_stop)    ;
    scan_test_set(NULL, &UNARY_stop, &UNARY_stop);
   }
  return result;
}

static void VAR_DECL(char* name, int offset)
{
  char* val;
  {
      void *key; \
        void *scp = *this_scope(); \
        if (symbol_lookup_key(table, &name, scp)) { \
                text_message(TEXT_ERROR, "redeclaration of '%s'\n", name); \
        } else { \
                key = symbol_insert_key(table, &name, sizeof(char*), sizeof(table_data)); \
                table_cast(key)->type   = INT; \
                table_cast(key)->offset = offset; \
                if (scp == global_scope) { \
                        fprintf(ft, "%s %d %d\n", name, INT, 0); \
                }  \
        } \

    if (scan_test(NULL, RDP_T_29 /* = */, NULL))
    { /* Start of rdp_VAR_DECL_1 */
      while (1)
      {
        {
          scan_test(NULL, RDP_T_29 /* = */, &VAR_DECL_stop);
          scan_();
          val = EXPR();
            \
  if (offset) { \
          fprintf(fp, "\t$fp(%d) = %s\n", offset, val); \
  } else { \
          fprintf(fp, "\t%s = %s\n", name, val); \
  } \

          }
        break;   /* hi limit is 1! */
      }
    } /* end of rdp_VAR_DECL_1 */
    scan_test(NULL, RDP_T_26 /* ; */, &VAR_DECL_stop);
    scan_();
    scan_test_set(NULL, &VAR_DECL_stop, &VAR_DECL_stop);
   }
}

static int WHILE(int offset)
{
  int result;
  char* val;
  {
    scan_test(NULL, RDP_T_while, &WHILE_stop);
    scan_();
     char* begin = new_lab(); \
        char* end = new_lab(); \
        push(&loop_stack, begin); \
        fprintf(fp, "%s\n", begin); \
 
    scan_test(NULL, RDP_T_19 /* ( */, &WHILE_stop);
    scan_();
    val = EXPR();
    scan_test(NULL, RDP_T_20 /* ) */, &WHILE_stop);
    scan_();
     fprintf(fp, "\tif %s == 0 goto %s\n", val, end + 1);  \
        void *scp = symbol_new_scope(table, NULL); \
        link_scope(scp); \
 
    result = SCOPE(scp, offset);
     fprintf(fp, "\tgoto %s\n", begin + 1); \
        fprintf(fp, "%s\n", end); \
        pop(&loop_stack); \
 
    scan_test_set(NULL, &WHILE_stop, &WHILE_stop);
   }
  return result;
}

int main(int argc, char *argv[])
{
  clock_t rdp_finish_time, rdp_start_time = clock();
  int
    rdp_symbol_statistics = 0,    /* show symbol_ table statistics flag */
    rdp_line_echo_all = 0,        /* make a listing on all passes flag */
    rdp_filter = 0,               /* filter flag */
    rdp_line_echo = 0;            /* make listing flag */

  unsigned long rdp_textsize = 35000l;   /* size of scanner text array */

  unsigned long rdp_tabwidth = 8l;   /* tab expansion width */

  char* rdp_vcg_filename = NULL;      /* filename for -V option */

  arg_message("rdparser\n" RDP_STAMP "\n\n""Usage: rdparser [options] source");

  arg_message("");
  arg_boolean('f', "Filter mode (read from stdin and write to stdout)", &rdp_filter);
  arg_boolean('l', "Make a listing", &rdp_line_echo);
  arg_string ('o', "Write output to filename", &rdp_outputfilename);
  arg_boolean('s', "Echo each scanner symbol as it is read", &rdp_symbol_echo);
  arg_boolean('S', "Print summary symbol table statistics", &rdp_symbol_statistics);
  arg_numeric('t', "Tab expansion width (default 8)", &rdp_tabwidth);
  arg_numeric('T', "Text buffer size in bytes for scanner (default 20000)", &rdp_textsize);
  arg_boolean('v', "Set verbose mode", &rdp_verbose);
  arg_string ('V', "Write derivation tree to filename in VCG format", &rdp_vcg_filename);

  rdp_sourcefilename = *arg_process(argc, argv);

  if (rdp_filter)
{
    rdp_sourcefilename = "-";
    rdp_outputfilename = "-";

}
  if (rdp_sourcefilename == NULL)
     arg_help("No source file specified");

  rdp_sourcefilename = text_default_filetype(rdp_sourcefilename, "");
  text_init(rdp_textsize, 25, 100, (int) rdp_tabwidth);
  scan_init(0, 0, 0, rdp_symbol_echo, rdp_tokens);
  table = symbol_new_table("table", 101, 31, symbol_compare_string, symbol_hash_string, symbol_print_string);
  rdp_set_initialise();
  rdp_load_keywords();
  if (rdp_verbose)
     text_printf("\nrdparser\n" RDP_STAMP "\n\n");
  for (rdp_pass = 1; rdp_pass <= RDP_PASSES; rdp_pass++)
  {
    text_echo(rdp_line_echo_all || (rdp_line_echo && rdp_pass == RDP_PASSES));
    if (text_open(rdp_sourcefilename) == NULL)
      arg_help("unable to open source file");

    text_get_char();
    scan_();

    TRNS_UNIT();            /* call parser at top level */
    if (text_total_errors() != 0)
      text_message(TEXT_FATAL, "error%s detected in source file\n", text_total_errors() == 1 ? "" : "s");   /* crash quietly */ 
  }
  if (rdp_symbol_statistics)
    symbol_print_all_table_statistics(11);

  text_print_total_errors();
  if (rdp_verbose)
  {
    rdp_finish_time = clock();
    text_message(TEXT_INFO, "%.3f CPU seconds used\n", ((double) (rdp_finish_time-rdp_start_time)) / CLOCKS_PER_SEC);
  }
  return rdp_error_return;
}

/* End of rdparser.c */
